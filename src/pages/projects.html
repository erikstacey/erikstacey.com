---
title: "Projects"
layout: layouts/page.njk
---
<center>
Also see minor projects, packages, and libraries on my <a href="https://github.com/erikstacey">github</a>!
</center>


<h3>
    <a href="https://github.com/erikstacey/pywhiten">Python package for Pre-Whitening (pywhiten)</a>
</h3>
<div class="img_wrapper"><img class="floating_img_r" src="../img/labeled_pg1.png" alt="pypw_periodogram" style="border: solid 2px rgb(0,0,0)"></div>
<p style="margin-bottom:120px;">
    A python package for performing frequency analyses of photometric observations of massive stars. The core functionality of this program was originally written to perform the analysis in my thesis, however was also found to be suitable for general application with photometric observations. At the core of pywhiten is a sophisticated multi-stage iterative pre-whitening algorithm, which matches or exceeds the accuracy of similar tools (e.g. <a href="http://period04.net/">Period04</a>). This program also fully
    automates the frequency analysis procedure, including error and significance analyses, which reduces the analysis time by up to 80% compared to a manual tool.
</p>

<h3><a href="https://saskatoon.ctvnews.ca/flying-high-u-of-s-students-successfully-launch-high-altitude-balloon-into-near-space-1.5963112">SasKatoon Altitude Temperature Experiment (SKATE)</a></h3>

<div class="img_wrapper"><img class="floating_img_l" src="../img/skate_burst.png" alt="pypw_periodogram" style="border: solid 2px rgb(0,0,0)"></div>
<p style="margin-bottom:120px;">
    A high-altitude balloon mission successfully built and flown as a part of the NSERC CREATE International Space Mission Training Program. The payload was principally designed to collected temperature and humidity data as a function of altitude, and included
    imaging instrumentation facing toward the horizon and up towards the balloon (Image: the helium balloon imaged from the payload moments after burst at 33km altitude). I led a team of five which wrote the software for the onboard computer and instrumentation.
    I also designed and constructed the electrical power system with another collaborator.

</p>

<h3><a href="https://github.com/erikstacey/phmin">phmin (Python Package)</a></h3>
<p style="margin-bottom:120px;">
    A small python package for performing frequency analysis on time series data using a phase dispersion minimization method. While principally designed and utilized for sparse photometric observations of stars, this package makes no (astronomical) assumptions about
    the input data and is therefore generally suitable for time series analysis of sparse data, particularly where non-sinusoidal signals are present.
</p>

<h3><a href="https://github.com/erikstacey/FLDCRV-GRID">FLDCRV-GRID (Fortran Program)</a></h3>
<p style="margin-bottom:120px;">
    A Fortran program based on a 1986 FORTRAN77 program FLDCRV, originally authored by John Landstreet. This program utilizes the core functionality of FLDCRV, which models the apparant longitudinal magnetic field of a magnetic star at given rotational phases
    given a set of physical and geometric parameters, while greatly improving useability and adding the ability to compute models and compare with observations simultaneously.
</p>

<h3>Veridian Game Engine</h3>
<p style="margin-bottom:2rem;">
    A video game engine for 2-D simulation-like games, taking direct inspiration from the highly optimized custom engine implemented in the logistics management and simulation game Factorio. 
    The fundamental structure of Veridian is written in C++ utilizing the Simple Directmedia Layer 2 library and is based on an entity-component-system (ECS) archtecture. The current implementation 
    stores entities as sets of data in several component storage classes linked using a unique entity ID, which has the critical advantage of permitting similar data belonging to an arbitrarily large
    number of game entities to be stored contiguously in memory. Under a traditional object-oriented approach, the CPU will load ALL data about each object into the cache where it can directly operate on it, including data that
    isn't going to be utilized by the current process. By storing data contiguously in memory by type (e.g. position, velocity) instead of by owner (e.g. blocks belonging to game objects consisting of a position, a velocity, a sprite, an inventory, etc.), the CPU can avoid loading a significant amount
    of irrelevant data in a single read from main memory, reducing the rate at which it has to pause its operations and perform costly transfers from the main memory to the cache (cache misses). This can lead to dramatic improvements in performance for the most computationally-heavy 
    behavioural systems in simulation-type games which often operate on a small subset of data from each of a large sample of entities.
</p>
<p style="margin-bottom:120px;">
    This is a passion project focused more on expanding my skills in performance optimization as well as my knowledge of software architectures and design patterns as opposed to game design, as it'd make far more sense to choose an existing ECS framework (e.g. FLECS) if the latter were my primary objective.
    Nonetheless, in the long term I'm working towards building a simulation game including complex logistics, manufacturing, and environmental control (temperature, pressure) management elements.
</p>


